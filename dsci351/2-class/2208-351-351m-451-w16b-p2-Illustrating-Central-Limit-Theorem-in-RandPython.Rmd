---
title: "DSCI351-351m-451: Class 14a p3 Illustrating CLT in R and Python "
subtitle: "2108-351-351m-451-w14a-p3-Illustrate-Central-Limit-Theorem-in-RandPython"
author: "Roger H. French, Sameera Nalin Venkat, Raymond Weiser" 
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_notebook:
  pdf_document:
    latex_engine: xelatex
    toc: TRUE
    number_sections: TRUE
    toc_depth: 6
    highlight: tango
  html_document:
    css: ../lab.css
    highlight: pygments
    theme: cerulean
    toc: yes
    toc_depth: 6
    toc_float: yes
    df_print: paged
urlcolor: blue
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = FALSE, # if TRUE knitr will cache results to reuse in future knits
  fig.width = 6, # the width for plots created by code chunk
  fig.height = 4, # the height for plots created by code chunk
  fig.align = 'center', # how to align graphics. 'left', 'right', 'center'
  dpi = 300, 
  dev = 'png', # Makes each fig a png, and avoids plotting every data point
  # eval = FALSE, # if FALSE, then the R code chunks are not evaluated
  # results = 'asis', # knitr passes through results without reformatting
  echo = TRUE, # if FALSE knitr won't display code in chunk above it's results
  message = TRUE, # if FALSE knitr won't display messages generated by code
  strip.white = TRUE, # if FALSE knitr won't remove white spaces at beg or end of code chunk
  warning = FALSE, # if FALSE knitr won't display warning messages in the doc
  error = TRUE) # report errors
  # options(tinytex.verbose = TRUE)
```

 \setcounter{section}{16}
 \setcounter{subsection}{2}
 \setcounter{subsubsection}{2}


#### Two high level, interpretted languages for Data Science

- R and [Python](https://en.wikipedia.org/wiki/Python_(programming_language) 

  - are high level scripting languages
  - They are "interface" languages, that serve
    - To provide a comfortable environment for people
  - While connecting to efficient code libraries in other languages
  
We can use both R and Python3 code blocks in Rstudio

  - Just change the beginning from
    - ```{r}
    - ```{python}

#### Illustrating the Central Limit Theorem in R and Python3

- This is the first article in our series "Lost in Translation between R and Python". 

  - The aim to provide high-quality R and Python 3 code 
    - to achieve some non-trivial tasks. 
  - If you want to learn Python, and you know R, 
    - then the Python code will be new to you.
    - but it does the same as the R code we'll do first

Let's start with a little bit of statistics 

  - Illustrating the Central Limit Theorem (CLT).

Take a sample of a random variable $X$ with finite variance. 

The CLT says: No matter how "unnormally" distributed $X$ is, 

  - its sample mean $\bar{x}$ 
    - will be approximately normally distributed, 
    - at least if the sample size is not too small. 
    
This classic result is the basis 

  - to construct simple confidence intervals 
  - and hypothesis tests for the (true) mean of $X$, 
    - i.e. $\mu$
  - check out Wikipedia for information on the [Central Limit Theorem](https://en.wikipedia.org/wiki/Central_limit_theorem).

#### R code: So lets do a simulation of the CLT and LLN

The code below illustrates this famous statistical result by simulation, 

  - using a very asymmetrically distributed $X$, 
  - namely $X = 1$ 
    - with probability 0.2 
  - and $X = 0$ otherwise. 
  
$X$ could represent the result of 

  - asking a randomly picked person whether he smokes. 
  - Conducting such a poll, 
    - the mean of the collected sample of such results 
  - would be a statistical estimate of 
    - the proportion of people smoking.

Curiously, by a tiny modification, 

  - the same code will also illustrate another key result in statistics 
    - the [Law of Large Numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers): 
  - For growing sample size, 
    - the distribution of the sample mean of $X$ 
    - contracts to the expectation $E(X)$.
    
```{r}
# Fix seed, set constants
set.seed(2006)
sample_sizes <- c(1, 10, 30, 1000)
nsims <- 10000
```

Lets make a helper function in R

```{r}
# Helper function: Mean of one sample of X
one_mean <- function(n, p = c(0.8, 0.2)) {
  mean(sample(0:1, n, replace = TRUE, prob = p))
}
one_mean(10)
```

##### Now lets run our simulation 1000 times for the CLT in R

```{r}
# Simulate and plot
par(mfrow = c(2, 2), mai = rep(0.4, 4))

for (n in sample_sizes) {
  means <- replicate(nsims, one_mean(n))
  hist(means, breaks = "FD",
       # xlim = 0:1, # uncomment for LLN
       main = sprintf("n=%i", n))
}
```
The CLT result is 

  - The larger the sample size, 
    - the closer the histogram of the simulated means 
    - resembles a symmetric bell shaped curve.



##### Now lets look at the Law of Large Numbers in R

```{r}
# Simulate and plot
par(mfrow = c(2, 2), mai = rep(0.4, 4))

for (n in sample_sizes) {
  means <- replicate(nsims, one_mean(n))
  hist(means, breaks = "FD",
       xlim = 0:1, # uncomment for LLN
       main = sprintf("n=%i", n))
}
```

And the Law of Large Numbers

Fixing the x-scale illustrates - for free(!) 

  - the Law of Large Numbers: 
  - The distribution of the mean 
    - contracts more and more 
    - to the expectation value of 0.2.

#### Python3 code: So lets do a simulation of the CLT and LLN

- First import some python packages

  - namely [`numpy`](https://en.wikipedia.org/wiki/NumPy) for 
    - a Python library that adds support for 
    - large, multi-dimensional arrays and matrices, 
    - along with a large collection of high-level mathematical functions 
    - to operate on these arrays.
  - and [`matplotlib`](https://en.wikipedia.org/wiki/Matplotlib) for plotting
    - is a Python plotting library 
    - that works with `numpy`, the numerical mathematics package. 
    - It provides an object-oriented API for embedding plots into applications 
    - using general-purpose GUI toolkits like Tkinter, wxPython, Qt, or GTK. 

```{r}
library(reticulate) 
```



```{python}
# First we'll 'import' some Python3 packages
  # This is analogous to 'library'ing in some R packages
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
# matplotlib$use("Agg", force = TRUE) # this makes the matplotlib plot appear in Rmarkdown
```
Now lets set seed and some constants for 1000 simulation runs

```{python}
# Fix seed, set constants
np.random.seed(100)
sample_sizes = [1, 10, 30, 1000]
nsims = 10_000
```

Lets make our helper function to calculate the mean of one sample

```{python}
# Helper function: Mean of one sample
def one_mean(n, p=0.2):
    return np.random.binomial(1, p, n).mean()

one_mean(10)
```

##### Now lets run our simulation 1000 times for the CLT in Python3

```{python}
# Simulate and plot
fig, axes = plt.subplots(2, 2, figsize=(8, 8))

for i, n in enumerate(sample_sizes):
    means = [one_mean(n) for ell in range(nsims)]
    ax = axes[i // 2, i % 2]
    ax.hist(means, 50)
    ax.title.set_text(f'$n = {n}$')
    ax.set_xlabel('mean')
    # ax.set_xlim(0, 1)  # uncomment for LLN
fig.tight_layout()
plt.show()
```

The CLT result is 

  - The larger the sample size, 
    - the closer the histogram of the simulated means 
    - resembles a symmetric bell shaped curve.


##### Now lets look at the Law of Large Numbers in Python3

```{python}
# Simulate and plot
fig, axes = plt.subplots(2, 2, figsize=(8, 8))

for i, n in enumerate(sample_sizes):
    means = [one_mean(n) for ell in range(nsims)]
    ax = axes[i // 2, i % 2]
    ax.hist(means, 50)
    ax.title.set_text(f'$n = {n}$')
    ax.set_xlabel('mean')
    ax.set_xlim(0, 1)  # uncomment for LLN
fig.tight_layout()
plt.show()
```

And the Law of Large Numbers

Fixing the x-scale illustrates - for free(!) 

  - the Law of Large Numbers: 
  - The distribution of the mean 
    - contracts more and more 
    - to the expectation value of 0.2.


    
#### Links

- Michael Mayer, Lost in Translation between R and Python Series, 021-01-07
  
  - [Illustrating the Central Limit Theorem](https://lorentzen.ch/index.php/2021/01/07/illustrating-the-central-limit-theorem/)


