---
title: "DSCI351-351m-451: Class 8a Functional vs Object Oriented Programming "
subtitle: "2208-351-351m-451-10a-p-FunctionalObjectOriented"
author: "Paul W. Leu" 
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  pdf_document:
    latex_engine: xelatex
    toc: TRUE
    number_sections: TRUE
    toc_depth: 6
    highlight: tango
  html_notebook:
  html_document:
    css: ../lab.css
    highlight: pygments
    theme: cerulean
    toc: yes
    toc_depth: 6
    toc_float: yes
    df_print: paged
urlcolor: blue
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = FALSE, # if TRUE knitr will cache results to reuse in future knits
  fig.width = 6, # the width for plots created by code chunk
  fig.height = 4, # the height for plots created by code chunk
  fig.align = 'center', # how to align graphics. 'left', 'right', 'center'
  dpi = 300, 
  dev = 'png', # Makes each fig a png, and avoids plotting every data point
  # eval = FALSE, # if FALSE, then the R code chunks are not evaluated
  # results = 'asis', # knitr passes through results without reformatting
  echo = TRUE, # if FALSE knitr won't display code in chunk above it's results
  message = TRUE, # if FALSE knitr won't display messages generated by code
  strip.white = TRUE, # if FALSE knitr won't remove white spaces at beg or end of code chunk
  warning = FALSE, # if FALSE knitr won't display warning messages in the doc
  error = TRUE) # report errors
  # options(tinytex.verbose = TRUE)
```

 \setcounter{section}{8}
 \setcounter{subsection}{0}
 \setcounter{subsubsection}{1}

#### Class Readings, Assignments, Syllabus Topics

##### Reading, Lab Exercises, SemProjects

  - Readings: 
    - For today: 
    - For next class: 
  - Laboratory Exercises: 
    - LE 4: due today
    - LE 5: Thursday, 11/10
  - Office Hours: (Class Canvas Calendar for Zoom Link)
    - Mondays @ 4:30 PM to 5:30 PM
    - Wednesdays @ 4:30 PM to 5:30 PM  
    - **Office Hours are on Zoom, and recorded**
  - Semester Projects
    - DSCI 451 Students Biweekly Update 4 Due this Friday
    - DSCI 451 Students 
      - Next Report Out #2 is Due Friday October 28th
    - All DSCI 351/351M/451 Students: 
      - Final: Monday 12/13/2021, 12:00PM - 3:00PM, Nord 356 or remote
      
#### Syllabus

![DSCI351-351M-451 Syllabus](./figs/syllabus.png)
### Functional vs Object Oriented Programming

Two programming paradigms

  - Functional programming is a paradigm based on writing functions
  - Object oriented programming is a paradigm based around `objects`, which can be data and code
  
  - R is a functional language.  
  - OOP is more challenging in R because
    - there are multiple OOP systems (S3, R6, S4)

Typically in R, you use functional programming, where you solve complex problems by 

  - decomposing them into simple functions, not objects.  


## Functional Programming

Decompose a big problem into smaller pieces, then solve each piece with a function of combination of functions.  

### Functions

Functions are composed of 

  - arguments or `formals()`, that control how you call the function
  - body or `body()`, the code inside the function
  - environment or `environment()`, the data structure that determines how the function finds values associated with the names.
  
```{r}
Sum <- function(x, y) {
  return(x + y)
}

formals(Sum)
body(Sum)
environment(Sum)
```

R also has many primitive functions, which call C code directly.

Primitive functions are written in R so their 
`formals()`, `body()`, and `environment()` are all NULL:
```{r}
typeof(sum)

formals(sum)
body(sum)
environment(sum)

```
R functions are objects and often called *first-class functions*. They can, just as any other object, be

  - bound to names, 
  - passed as arguments, and 
  - returned from other functions.  

When you name a function, use a "command" verb in CamelCase.
Keep your functions short (30 lines or less), so that they can be combined in a modular manner.

You can use *anonymouse functions* if you think you will only use a function once and do not want to give a name.  

```{r}
sapply(mtcars, function(x) length(unique(x)))
```

In R, functions are called *closures*. This is because they  enclose their environments.

```{r}
typeof(Sum)
body(Sum)

y <- 1
f <- function(x) x + y
f(3)



```

### Functionals 

A *functional* is a function that takes a function as an input and returns a vector as an output.  

`lapply()`, `sapply()`, `apply()` are functionals.  
Mathematical functions like `integrate()` are functionals.  

```{r}
sapply(mtcars, typeof)
integrate(function(x) sin(x), 0, pi)
```
The most important functional is `map()` which is included as part of tidyverse.  It takes 
  - a vector and 
  - a function 
and returns
  - a list
  
`map(1:3, f)` is equivalent to `list(f(1), f(2), f(3))`


```{r}
library(tidyverse)
triple <- function(x) x * 3
map(1:3, triple)

```

There are variants of `map()`: `map_lgl()`, `map_int()`, `map_dbl()`, `map_chr()`, and `map_dfr()`.  
Each returns an atomic vector of a different type: 
logical, integer, double, character, and dataframe, respectively.  


```{r}
map_chr(mtcars, typeof)

mtcars_by_cyl <- split(mtcars, mtcars$cyl)
slopes <- double(length(mtcars_by_cyl))
intercepts <- double(length(mtcars_by_cyl))
for (i in seq_along(mtcars_by_cyl)) {
  model <- lm(mpg ~ wt, data = mtcars_by_cyl[[i]])
  slopes[[i]] <- coef(model)[[2]]
  intercepts[[i]] <- coef(model)[[1]]
}
df_model <- as.data.frame(t(rbind(intercepts, slopes)))


df_model2 <- mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .x)) %>%
  map_dfr(~ as.data.frame(t(as.matrix(coef(.))))) %>%
  rename(intercepts = `(Intercept)`, slopes = wt)
```


## Object Oriented Programming

Main reason to use OOP is *polymorphism*.  
Polymorphism means that a develop can consider a function's interface seprately from the implementation.  

This is related to *encapsulation* where the user doesn't have to worry about the details of an object.  This facilitates code refactoring.  How data is represented internally can be changed without worrying about how external code interacts with this object.  

Polymorphism is what allows `summary()` to produce different outputs for numeric and factor variables.  
```{r}
summary(diamonds$carat)
summary(diamonds$cut)
```

The type of object is its *class* and an implementation for a specific class is called a *method*.

The class defines the *fields*, the data possessed by every instance of that class.  Classes are organised in a hierarchy so that if a method does not exist for one class, its parentâ€™s method is used, and the child is said to inherit behaviour. 

In encapsulated OOP, methods belong to objects or classes, and method calls typically look like `object.method(arg1, arg2)`. This is called encapsulated because the object encapsulates both data (with fields) and behaviour (with methods), and is the paradigm found in most popular languages.


```{r}
setClass("Student", 
  slots = c(
    name = "character", 
    IDnumber = "numeric",
    email = "character",
    team = "character"
  )
)

john <- new("Student", name = "John Smith", email = "john.smith@pitt.edu", IDnumber = 1234567, team = "")
john@name

#setMethod("send_email", "Student", function(x) {
  ## code to send email
#} 

```



#### Links

  - Hadley Wickham, [Advanced R](https://adv-r.hadley.nz/)

